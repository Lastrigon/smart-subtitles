// Generated by CoffeeScript 1.3.3
(function() {
  var SubtitleRead, print, root;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  print = console.log;

  SubtitleRead = (function() {

    function SubtitleRead(subtitleText) {
      var awaitingTime, endTime, line, lineContents, processLine, processSubtitle, startTime, timeToSubtitle, timesAndSubtitles, triplet, _i, _j, _len, _len1, _ref;
      this.subtitleText = subtitleText;
      timeToSubtitle = {};
      timesAndSubtitles = [];
      awaitingTime = true;
      startTime = 0.0;
      endTime = 0.0;
      lineContents = '';
      processLine = function(line) {
        var toSeconds, _ref;
        line = line.trim();
        if (line === '') {
          if (lineContents !== '') {
            timesAndSubtitles.push([startTime, endTime, lineContents]);
          }
          awaitingTime = true;
          return lineContents = '';
        } else if (awaitingTime) {
          if (line.indexOf(' --> ') !== -1) {
            awaitingTime = false;
            _ref = line.split(' --> '), startTime = _ref[0], endTime = _ref[1];
            toSeconds = function(time) {
              var hour, min, sec, _ref1;
              if (time.indexOf(',') !== -1) {
                time = time.slice(0, time.indexOf(','));
              }
              _ref1 = time.split(':'), hour = _ref1[0], min = _ref1[1], sec = _ref1[2];
              hour = parseInt(hour);
              min = parseInt(min);
              sec = parseInt(sec);
              return Math.round(hour * 3600 + min * 60 + sec);
            };
            startTime = toSeconds(startTime);
            endTime = toSeconds(endTime);
            return awaitingTime = false;
          }
        } else {
          return lineContents = (lineContents + '\n' + line).trim();
        }
      };
      _ref = subtitleText.split('\n');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        processLine(line);
      }
      processSubtitle = function(triplet) {
        var _results;
        startTime = triplet[0], endTime = triplet[1], lineContents = triplet[2];
        _results = [];
        while (startTime < endTime) {
          timeToSubtitle[startTime] = lineContents;
          _results.push(++startTime);
        }
        return _results;
      };
      for (_j = 0, _len1 = timesAndSubtitles.length; _j < _len1; _j++) {
        triplet = timesAndSubtitles[_j];
        processSubtitle(triplet);
      }
      this.timeToSubtitle = timeToSubtitle;
    }

    SubtitleRead.prototype.subtitleAtTime = function(sec) {
      var retv;
      retv = this.timeToSubtitle[sec];
      if (retv) {
        return retv;
      } else {
        return '';
      }
    };

    return SubtitleRead;

  })();

  root.SubtitleRead = SubtitleRead;

}).call(this);
